% !TEX TS-program = pdfLaTeX+MakeIndex+BibTeX
% !TEX encoding = UTF-8 Unicode

\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{naturalnames}{hyperref}

\documentclass[tg]{mdtufsm}

\usepackage[T1]{fontenc}
\usepackage{fix-cm}
\usepackage{times, color}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath,latexsym,amssymb}
%\usepackage[hidelinks]{hyperref}
\usepackage[hidelinks,
            bookmarksopen=true,linktoc=none,colorlinks=true,
            linkcolor=black,citecolor=black,filecolor=magenta,urlcolor=blue,
            pdftitle={Exploração da Linguagem Rust para o Desenvolvimento de um Path Tracer Paralelo},
            pdfauthor={Yuri Kunde Schlesner},
            pdfsubject={Trabalho de Graduação},
            pdfkeywords={Computação de alto desempenho, programação web, Programação Paralela, Rust, Path Tracing, Informática, UFSM}
            ]{hyperref}
%\usepackage[brazilian]{babel}

%\usepackage{fontspec}
%\setmainfont{Linux Libertine G}

%%% PAGE DIMENSIONS
\usepackage[inner=30mm,outer=20mm,top=30mm,bottom=20mm]{geometry} 
\usepackage{epstopdf}
\usepackage{graphicx}
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
%\usepackage{amsfonts}
%\usepackage{color}
%\usepackage{booktabs} % for much better looking tables
%\usepackage{array} % for better arrays (eg matrices) in maths
%\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{listings}
\usepackage{parcolumns}
%\usepackage{microtype}
%\usepackage[numbers]{natbib}
%\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\lstset{
	basicstyle=\scriptsize\ttfamily,
	tabsize=2,
	frame=single,
	breaklines=true,
	breakatwhitespace=true,
	xleftmargin=0cm,
	xrightmargin=0cm,
	literate=
		{á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
		{Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
		{à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
		{À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
		{ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
		{Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
		{â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
		{Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
		{ã}{{\~a}}1 {Ã}{{\~A}}1
		{ç}{{\c c}}1 {Ç}{{\c C}}1
}

% For Computer Modern:
%\def\Cpp{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}}
% For Linux Libertine G
\def\Cpp{{C\nolinebreak[4]\raisebox{.20ex}{\small\bf++}}}

\newcommand{\todo}[1]{\textsf{\color{red}#1}}

\input{macros/bugcaption}

%%% END Article customizations

\title{Um sistema web para execução remota de aplicações de alto desempenho}
\author{Migliavacca Madalosso}{Otávio}
\course{Curso de Ciência da Computação}
\altcourse{Curso de Ciência da Computação}
\institute{Centro de Tecnologia}
\degree{Bacharel em Ciência da Computação}

\trabalhoNumero{}
\advisor[Profª.]{Drª.}{Charão}{Andrea Schwertner}
\orientadoratrue

\committee[Profª. Drª.]{non se sabe}{silva}{UFSM}
\committee[Prof. Dr.]{anon}{incognito}{UFSM}

\date{08}{Outubro}{2015}

\keyword{Computação de alto desempenho}
\keyword{Programação Web}
\keyword{!!!!!!!!!!!!!!!1}
\keyword{!!!!!!!!!!!!!!!3}
\keyword{!!!!!!!!!!!!!!!2}

%\date{} % Activate to display a given date or no date (if empty), otherwise the current date is printed

\begin{document}
\maketitle
\makeapprove

\begin{abstract}
Algumas áreas de pesquisa utilizam constantemente algoritmos que demandam alto desempenho dos seus ambientes de execução. Ocasionalmente, surgem algoritmos novos, com diferentes propriedades, que se propõem a resolver um problema de forma mais eficiente e/ou completa. Infelizmente, é comum que esses algoritmos fiquem restritos a ambientes institucionais, limitando muito a sua visibilidade para a comunidade de pesquisa. Este trabalho tem como objetivo criar um portal que permita ao usuário solicitar a execução remota de um algoritmo de acordo com as configurações que o sistema oferecer.
\end{abstract}

\tableofcontents

\setlength{\baselineskip}{1.5\baselineskip}

%	\item[Período de execução:] Setembro de 2014 a Dezembro de 2014
%	\item[Unidades participantes:] ~\\ Curso de Ciência da Computação \\ Departamento de Eletrônica e Computação
%	\item[Área de conhecimento:] Ciência da Computação
%	\item[Linha de Pesquisa:] Computação Gráfica, Linguagens de Programação, Programação Paralela
%	\item[Tipo de projeto:] Trabalho de Conclusão de Curso

\chapter{Introdução}

Algoritmos com grande custo computacional são facilmente encontrados em áreas como meteorologia, biologia e astronomia. Esses algoritmos possuem a característica de utilizar um nível elevado de processamento para concluir sua execução, e consequentemente, seus tempos de execução podem variar dependendo da máquina aonde estão sendo executados.

É comum pesquisadores destas e de outras áreas desenvolverem novas implementações de algoritmos utilizados por seus colegas. Implementações essas que podem trazer muitos benefícios para outros pesquisadores que necessitam deste tipo de solução. Infelizmente, é comum essas implementações ficarem restritas a ambientes privados, não por questões de licença, mas simplesmente pela ausência de um método prático para disponibilizar a nova ferramenta ao público.

Com isso, surge a ideia de desenvolver um portal web que permita ao usuário o cadastro de um experimento, no qual ele poderá ditar os dados de entrada desse experimento, e qual algoritmo (disponível no sistema) ele deseja utilizar para processar os dados. Depois de requisitar o experimento, o sistema deve providenciar sua execução e quando finalizar, retornar o resultado do experimento ao usuário que o requisitou.

Para este portal, será utilizado um algoritmo desenvolvido para a área de astronomia, uma versão do algoritmo Friends-of-Friends de complexidade n*log(n) paralelizada através do framework OpenMP.

\section{Objetivos}

\subsection{Objetivo Geral}

O objetivo deste trabalho é criar um portal web que possibilite aos usuários cadastrados no sistema  executar algoritmos utilizando diferentes dados e disponibilizar o resultado da execução após sua conclusão.

\section{Justificativa}

O projeto é capaz de gerar benefícios significativos para a comunidade de pesquisa de diversas áreas, criando um modelo de ambiente que facilite a divulgação e teste de resultados de algoritmos alternativos para resolução de problemas comuns.

Além de servir como modelo, o projeto disponibilizará um algoritmo que se enquadra na categoria alvo do projeto: a versão de complexidade n*log(n) e paralela do friends-of-friends.

\chapter{Fundamentos e Revisão de Literatura}


\section{Framework Django}
Django\cite{django} é um framework para criação de aplicações web que encoraja o desenvolvimento ágil, em alto nível e com design pragmático. Foi criado inicialmente para manter o portal de notícias online do Lawrence
Journal World pelos programadores Adrian Holovaty, Simon Willison e Jacob Kaplan-Moss.

Por se tratar de um portal inicialmente desenvolvido para administrar notícias, o framework lida muito  bem com gerenciamento de conteúdo e agilidade quando é necessário fazer alterações no sistema.


\section{Friends of Friends}
Simulações de N-corpos têm sido utilizadas para promover vários avanços na compreensão de questões relevantes em astrofísica, como por exemplo o processo de formação e evolução de estruturas do Universo. Este tipo de simulação tem um papel fundamental\cite{Bertschinger,Efstathiou} no estudo da evolução cósmica em tópicos como a distribuição de matéria escura em grande escala, a formação de halos de matéria escura, e a formação e evolução de galáxias e aglomerados.

A manipulação e análise da grande quantidade de dados produzidos em tais simulações também é algo desafiador.
Neste contexto, é essencial o desenvolvimento de técnicas computacionais eficientes para extrair informação
significativa a partir dessas fontes de dados, em um período apropriado de tempo.

Etapas importantes neste tipo de análise são a identificação de halos de matéria escura e o estudo do espectro da
energia potencial gravitacional de tais objetos. Uma abordagem para este tipo de análise consiste em usar o
algoritmo de percolação Friends-of-Friends (FoF) \cite{uchra} . A ideia básica deste algoritmo é a seguinte: considere uma
esfera de raio R ao redor de cada partícula do conjunto total; se dentro desta esfera existirem outras partículas, elas
serão consideradas pertencentes ao mesmo grupo e serão chamadas de amigas. Em seguida, toma-se uma espfera ao
redor de cada amiga e continua-se o procedimento usando a regra "qualquer amigo de meu amigo é meu amigo". O
procedimento para quando nenhuma amiga nova puder ser adicionada ao grupo.

Na 15ª edição da Escola Regional de Alto Desempenho do Rio Grande do Sul (XV ERAD-RS)(referenciar), foram publicados resultados de execuções de uma nova implementação do Friends-of-Friends\cite{friends} cuja complexidade computacional era reduzida em relação as versões anteriores, resultando em redução do tempo de processamento.


%\begin{figure}
%	\centering
%	\includegraphics[width=0.5\textwidth]{exemplo_imagem}
%	\caption{
%		Um exemplo de uma imagem gerada utilizando \emph{path tracing}. Note como a luz que atinge o
%		plano xadrez é refletida de volta para iluminar a esfera, um fenômeno conhecido como
%		\emph{iluminação indireta} e que é corretamente simulado pelo algoritmo.
%	}
%	\label{fig:path_tracing}
%\end{figure}

\chapter{Desenvolvimento}
A metodologia do projeto concentrou-se em dar prioridade aos requisitos que apresentavam maior risco, priorizando a funcionalidade de executar remotamente tarefas. Por causa disso foi feita uma "Sprint"  para agilizar o desenvolvimento de funcionalidades mais básicas do projeto, que dariam base ao sistema no qual iria ser desenvolvida a funcionalidade de requisição de execuções remotas pelos usuários, parte crítica do projeto.

Para isso, o projeto iniciou através do estudo e familiarização do framework Django, através de uma série de video aulas disponíveis no youtube e da documentação do framework, foram desenvolvidas as páginas de 'contato' e 'informações' da aplicação.

Através desse estudo de video aulas foram selecionados também algumas aplicações extensíveis que, conforme observou-se, poderiam trazer ganhos ao projeto em questão de agilidade de desenvolvimento. As aplicações estudadas foram o django-registration-redux, para registro de usuário, e o django-crispy-forms, que efetua alterações de formulários conforme o resultado da validação do mesmo.


\section{Formulário de Contato}
A página de contato do sistema foi desenvolvida utilizando um formulário que exige informações necessárias para identificação e endereço de resposta de quem efetuou o contato. Para isso foi utilizada a aplicação django-crispy-forms, ela trata de casos como o de quando um usuário tenta efetuar um contato e não preenche um dos campos necessários, dependendo do resultado da validação, efetuada no backend do sistema, é retornado um novo formulário semelhante ao original, porém, com mensagens deixando explícito ao usuário quais foram os erros cometidos na tentativa de efetuar contato.

\section{Registro de Usuário}
Depois disso houve o estudo da logística de registro de usuários, como a aplicação deve ser aberta a qualquer pessoa, é imprescindível que haja uma forma autônoma de registro de novos usuários. No primeiro momento tentou-se implementar a funcionalidade utilizando formulários e verificações desenvolvidas no proprio projeto, mas durante o desenvolvimento foi encontrada uma solução mais rápida e mais adequada, o uso do app Django-Registration-Redux.

O django-registration-redux é uma aplicação extensível que provê as funcionalidades de registro de usuários para sites que utilizam Django. Essa aplicação já dispõe de templates e formulários para fazer a sua função. Por padrão ela mantém apenas os dados de email, nome e senha do usuário que solicitou o registro, o que satisfaz os requisitos mínimos para executar sua funcionalidade, porém para o sistema em desenvolvimento, pareceu interessante ter a possibilidade de obter mais dados do usuário em seu cadastro, tais como instituição a qual o usuário pertence (Universidade, empresa, etc.), grau de escolaridade, e outras informações que podem ser úteis posteriormente ao administrador do sistema.
Além disso, o django-registration-redux não tem por padrão, nenhuma forma de filtro de domínios de endereços de email, o que também pode ser útil ao sistema, caso o administrador queira limitar o acesso do portal aos usuários que detenham um email de um domínio específico.

Para contornar essas questões, foi criado um novo modelo de dados que extende a aplicação registration-redux, tornando possível extender as funções de registro para esse modelo novo, de modo que no processo de registro novos dados podem ser requisitados, verificados e validados pelo sistema antes de proceder com a criação do usuário.

\section{Modelos de dados}
Quando a etapa de registro de usuários foi completa, foram criados modelos de dados para representar os algoritmos disponíveis pelo sistema, execuções que seriam requisitadas pelos usuários, e modelos de execuções.

Essas três classes, combinados com a classe de usuário, que mantém os dados do registro, compõem o modelo de dados(Figura 3.1) que integram todas as funcionalidades do sistema até o presente estado de desenvolvimento.

\subsection{Algorithm}
Essa classe é responsável por manter os dados referentes ao(s) algoritmo(s) que o sistema disponibiliza, é composto por 3 atributos que representem o nome do algoritmo, a descrição de seu propósito, e o comando (shell) que deverá ser utilizado para executá-lo.

\subsection{ExecModel}
Essa classe foi criada para permitir ao usuário testar os serviços do sistema sem precisar de um conjunto de dados. Assim, essa classe guarda dados referentes a execução pré-definida de um algoritmo, utilizando os dados de entrada já configurados pelo administrador do sistema. Além disso, ele mantém um campo descrição criado com o intúito de explicar ao usuário como funciona o conjunto de dados utilizados como entrada e o que se espera do resultado após o processamento.

\subsection{Execution}
A classe Execution mantém todas as informações referentes a um pedido de execução. Ela inclui uma chave estrangeira que referencia o usuário que requisitou-a, a data na qual a requisição foi feita, o status da execução, outra chave estrageira que referencia qual algoritmo será utilizado, e dois campos para os endereços nos quais devem ser mantidos os dados de entrada e saída à serem usados nesta execução.

\subsection{PortalUser}
Representa o usuário no protal, mantém os dados de cadastro e mais alguns referêntes a datas e preferências:

\begin{itemize}
	\item Username (Utilizado para o login)
	\item Password 
	\item E-mail
	\item Nickname (Utilizado para mensagens de contato e alertas pelo sistema)
	\item DateRegister (Data de quando foi feito o registro do usuário)
	\item LastAcess (Data do último acesso do usuário no sistema)
	\item ResultsPerPage (Preferência de quantos resultados por página o usuário deseja quando for listar os experimentos que requisitou)
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{class_diagran_tg}
	\caption{
		Diagrama de classes do projeto.
	}
	\label{fig:path_tracing}
\end{figure}


\section{Execução Remota de tarefas}
A execução remota de tarefas foi um requisito que exigiu outro estudo em busca de ferramentas e tecnicas para sua realização. É necessário esclarecer que não é viável que o próprio processo que mantém a aplicação no ar e trata de todos os requests realizados por usuários também lide com as execuções dos experimentos solicitados pelos usuários, pois isso causaria uma lentidão muito grande no sistema.

Para contronar esse problema foram verificadas duas técnicas: a criação de um novo processo que faria a execução do experimento, ou então o uso de alguma aplicação que gerencia-se filas de tarefas e distribuição das mesmas para demais processos e/ou máquinas.

Compreendida a dimensão e complexidade de criar um sistema para execução de tarefas a partir do zero, optou-se por buscar por aplicações compatíveis com as tecnologias utilizadas do projeto e que pudessem satisfazer a necessidade identificada.

---PORQUE CELERY---

BROKER lidar mensagens

Worker

\section{Funcionalidades}
As funcionalidades do sistema podem ser divididas até agora em 3 grupos distintos.
\subsection{Usuário Anonimo}
Um usuário anônimo possui a permissão de acessar áreas de informação a respeito do sistema, de contato com o administrador do sistema, e da área de registro, onde pode solicitar o registro e, seguindo as orientações apresentadas, fazer login como um usuário registrado.
\subsection{Usuário registrado}
O usuário registrado tem permissão de criar experimentos no portal, para isso ele faz o \emph{upload} de um arquivo que será utilizado como entrada no algoritmo selecionado. Além disso o usuário também pode monitorar o estado dos experimentos que ele requisitou e fazer o \emph{download} dos arquivos de cada experimento, tanto o arquivo de entrada, como a saída(se houver) do algoritmo.
\subsection{Administrador}
O administrador tem as mesmas capacidades do que um usuário registrado e detem previlégios de acesso ao painel de administração do django. Isso permite a ele cadastro de novos algoritmos no sistema, de novos experimentos padrão e a editar qualquer informação que o sistema detenha no banco de dados.


\section{Sistema de Arquivos}
Como as tarefas realizadas pelo portal exigem dados para serem processados pelo algoritmo, e esse algoritmo gera novos dados, foi necessário criar um sistema de arquivos para manter uma ordem na qual seja possível recuperar esses arquivos após o seu processamento.
O sistema foi implementado conforme a imagem ilustra. Nele, é escolhido um diretório como sendo a raíz de todos os arquivos que o portal irá manter referente a dados de entrada e saída dos algoritmos, e esses dados serão mantidos em diretórios nomeados de acordo com o id do experimento ao qual pertencem, e esse diretório, por sua vez, será mantido em um outro diretório nomeado de acordo com o id do usuário que requisitou o experimento.

Após a implementação desse sistema de arquivose e combinando as funcionalidades implementadas com o que já havia sido implementado referente a execução de tarefas, foi possível desenvolver uma página no portal na que o usuário pudesse obter os arquivos de dados referentes a cada experimento solicitado por ele e verificar o estado de cada experimento. Esses estados são definidos de acordo com o andamento do processo de execução, sendo que até o momento, são possíveis 3 estados: 


\begin{itemize}
	\item "Aguardando": Experimento aguarda sua execução por um worker.
	\item "Executando": Experimento está sendo executado, mas ainda não concluíu.
	\item "Finalizado": Experimento já foi executado e já possui os dados disponíveis para o usuário.
\end{itemize}

\iffalse
\begin{itemize}
	\item Ambiente de Desenvolvimento
	\item Organização do Projeto
	\item Modelos de dados
	\item Funcionalidades
	\item Design
	\item Administração
\end{itemize}

\section{Ambiente de Desenvolvimento}

\subsection{Sistema Operacional}

Para o desenvolvimento do projeto está sendo utilizado o sistema operacional Ubuntu 14.04(REF?), que contém um interpretador da linguagem Python(REF)?, sendo necessário apenas fazer a instalação do framework Django 1.8(REF?) para ter um ambiente pronto para começar o desenvolvimento do projeto. Além disso, também foi instalado o sistema de gerenciamento de pacotes pip(REF), que foi utilizado para instalação de outras ferramentas (descritas abaixo) que auxiliaram no desenvolvimento.

\subsection{Ferramentas de Programação}
Para auxiliar na tarefa de programação do sistema, foi utilizado o editor de texto Sublime Text 2 (REF!), um blabla.... utilizando também o plugin Anaconda... Django algo...

\subsection{Controle de Versão - Repositório}

Para realizar o controle de versões foi utilizado o \emph{Git}\footnote{O repositório com o código pode ser encontrado em \url{https://github.com/Madalosso/TG}}, também utilizado pelo projeto original.

\section{Organização do Projeto}

O framework Django tem uma proposta de criar aplicações fáceis de serem reutilizadas por outros projetos, e por conta disso tem uma abordagem bastante metódica e pouco flexível em relação a distribuição dos arquivos que pertencem ao projeto. Consequentemente, a organização utilizada é a mesma proposta pela documentação do framework, que pode ser observada na figura abaix (incluir figura)

\subsection{\emph{manage.py}}
explicar a funcionalidade do manage e sua importancia para todo o projeto
\subsection{\emph{Static Files}}
Os arquivos estáticos que o projeto mantém são todos organizados dentro do diretório "static in pro", lá são mantidos arquivos que precisam estar disponíveis por qualquer documento html, em grande maioria são arquivos .css, .js e imagens comuns às páginas do projeto.
\subsection{\emph{Media url}}
Media URL é a variável responsável por indicar ao sistema qual diretório será a raiz dos arquivos que serão manipulados pelo sistema. Dentro desse diretório raiz existe uma pasta "Users" e dentro dela, uma pasta com o id de cada usuario cadastrado no banco de dados. Para cada experimento criado por um usuário, em seu respectivo diretório será criado um novo diretório cujo nome será o identificador do experimento, e dentro desse diretório serão mantidos os arquivos de entrada e saída do experimento.
\subsection{\emph{views.py}}
Esse arquivo contém as funções que definem telas a serem exibidas para os utilizadores do sistema. Como padrão toda função nesse arquivo recebe com um \emph{request} e retorna alguma resposta html, essa resposta na maioria dos casos utiliza arquivos presentes no diretório "Templates".



\begin{figure}
	\centering
	\begin{minipage}[t]{0.48\textwidth}
\begin{lstlisting}
enum Algorithm {
	kEyeLight,
	kPathTracing,
	kLightTracing,
	kProgressivePhotonMapping,
	kBidirectionalPhotonMapping,
	kBidirectionalPathTracing,
	kVertexConnectionMerging,
	kAlgorithmMax
};

static const char* GetName(Algorithm aAlgorithm) {
	static const char* algorithmNames[7] = {
		"eye light",
		"path tracing",
		"light tracing",
		"progressive photon mapping",
		"bidirectional photon mapping",
		"bidirectional path tracing",
		"vertex connection and merging"
	};

	if(aAlgorithm < 0 || aAlgorithm > 7)
		return "unknown algorithm";

	return algorithmNames[aAlgorithm];
}

static const char* GetAcronym(Algorithm aAlgorithm) {
	static const char* algorithmNames[7] = {
		"el", "pt", "lt", "ppm", "bpm", "bpt", "vcm" };

	if(aAlgorithm < 0 || aAlgorithm > 7)
		return "unknown";
	return algorithmNames[aAlgorithm];
}
\end{lstlisting}
	\end{minipage}
	~
	\begin{minipage}[t]{0.48\textwidth}
\begin{lstlisting}
enum Algorithm {
	EyeLight,
	PathTracing,
	LightTracing,
	ProgressivePhotonMapping,
	BidirectionalPhotonMapping,
	BidirectionalPathTracing,
	VertexConnectionMerging,
}

impl Algorithm {
	fn get_name(self) -> &'static str {
		match self {
			EyeLight => "eye light",
			PathTracing => "path tracing",
			LightTracing => "light tracing",
			ProgressivePhotonMapping => "progressive photon mapping",
			BidirectionalPhotonMapping => "bidirectional photon mapping",
			BidirectionalPathTracing => "bidirectional path tracing",
			VertexConnectionMerging => "vertex connection and merging",
		}
	}

	fn get_acronym(self) -> &'static str {
		match self {
			EyeLight => "el",
			PathTracing => "pt",
			LightTracing => "lt",
			ProgressivePhotonMapping => "ppm",
			BidirectionalPhotonMapping => "bpm",
			BidirectionalPathTracing => "bpt",
			VertexConnectionMerging => "vcm",
		}
	}
}
\end{lstlisting}
	\end{minipage}
	\caption{Comparação entre \emph{enums} em C++ e \emph{Rust}}
	\label{code:enums}
\end{figure}

Para a leitura de parâmetros passado via linha de comando, é utilizada o módulo \texttt{getopts} presente na biblioteca padrão. Na versão \Cpp\ a leitura é feita de forma manual.



\begin{figure}
\begin{lstlisting}
// Definição da macro
macro_rules! impl_Vector_traits(
	($Self:ident { $($field:ident),+ }) => (
		impl<T: Num> Add<$Self<T>, $Self<T>> for $Self<T> {
			#[inline]
			fn add(&self, o: &$Self<T>) -> $Self<T> {
				$Self {
					$($field: self.$field + o.$field),+
				}
			}
		}
		// ...
		impl<T: Num> Neg<$Self<T>> for $Self<T> {
			#[inline]
			fn neg(&self) -> $Self<T> {
				$Self {
					$($field: -self.$field),+
				}
			}
		}		
		// ...
		impl<T: Num> Index<uint, T> for $Self<T> {
			#[inline]
			fn index(&self, index: &uint) -> &T {
				[$(&self.$field),+][*index]
			}
		}
	)
)

// Definição dos tipos
#[deriving(Copy, Clone)]
pub struct Vector2<T> { pub x: T, pub y: T }
#[deriving(Copy, Clone)]
struct Vector3<T> { pub x: T, pub y: T, pub z: T }

// Instanciação da macro
impl_Vector_traits!(Vector2 { x, y })
impl_Vector_traits!(Vector3 { x, y, z })
\end{lstlisting}
\begin{lstlisting}
// Expansão de impl_Vector_traits!(Vector2 { x, y })
impl<T: Num> Add<Vector2<T>, Vector2<T>> for Vector2<T> {
	#[inline]
	fn add(&self, o: &Vector2<T>) -> Vector2<T> {
		Vector2 {
			x: self.x + o.x,
			y: self.y + o.y
		}
	}
}
// ...
impl<T: Num> Neg<Vector2<T>> for Vector2<T> {
	#[inline]
	fn neg(&self) -> Vector2<T> {
		Vector2 {
			x: -self.x,
			y: -self.y
		}
	}
}
// ...
impl<T: Num> Index<uint, T> for Vector2<T> {
	#[inline]
	fn index(&self, index: &uint) -> &T {
		[self.x, self.y][*index]
	}
}
\end{lstlisting}
	\caption{Definição e uso de uma macro e sua expansão}
	\label{code:mathmacro}
\end{figure}

I don't want this to happen
\fi
\chapter{Próximas Etapas}

Como continuação do trabalho realizado até o momento, são planejadas as seguintes atividades:

\begin{enumerate}
	\item fazer a execução das tarefas em uma máquina diferente da que mantém o portal.
	\item Avaliar novas idéias de funcionalidades e implementar as que forem validadas.
	\item tornar site responsivo via bootstrap.
\end{enumerate}

\setlength{\baselineskip}{\baselineskip}
\bibliographystyle{abnt}
\bibliography{../graphics,../languages}

\end{document}
